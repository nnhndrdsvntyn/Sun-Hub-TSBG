-- Variables to store the spheres and line
local targetSphere = nil
local localPlayerSphere = nil
local lineBetweenSpheres = nil

local function getNearestPlayer()
    local players = game:GetService("Players")
    local localPlayer = players.LocalPlayer
    local nearestPlayer = nil
    local shortestDistance = math.huge

    for _, player in ipairs(players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local magnitude = (player.Character.HumanoidRootPart.Position - localPlayer.Character.HumanoidRootPart.Position).Magnitude
            if magnitude < shortestDistance then
                shortestDistance = magnitude
                nearestPlayer = player
            end
        end
    end
    return nearestPlayer, shortestDistance
end

local function updateTurnLock()
    if turnLockEnabled then
        local nearestPlayer, distance = getNearestPlayer()

        if nearestPlayer and nearestPlayer.Character and nearestPlayer.Character:FindFirstChild("HumanoidRootPart") then
            if distance <= lockRadius then  -- Check if the player is within the set radius
                local myHRP = game.Players.LocalPlayer.Character.HumanoidRootPart
                local targetPosition = nearestPlayer.Character.HumanoidRootPart.Position
                myHRP.CFrame = CFrame.new(myHRP.Position, Vector3.new(targetPosition.X, myHRP.Position.Y, targetPosition.Z))
                currentTarget = nearestPlayer.Name
                distanceToNearestPlayer = string.format("%.0f", distance)

                -- Create or update the sphere above the target
                if not targetSphere then
                    targetSphere = Instance.new("Part")
                    targetSphere.Shape = Enum.PartType.Ball
                    targetSphere.Size = Vector3.new(1, 1, 1)  -- 1x1x1 sphere
                    targetSphere.Color = Color3.fromRGB(255, 0, 0)  -- Red color
                    targetSphere.Material = Enum.Material.Neon
                    targetSphere.Anchored = true
                    targetSphere.CanCollide = false
                    targetSphere.Transparency = 0.5
                    targetSphere.Parent = workspace
                end
                targetSphere.Position = nearestPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 5, 0)

                -- Create or update the sphere above the local player
                if not localPlayerSphere then
                    localPlayerSphere = Instance.new("Part")
                    localPlayerSphere.Shape = Enum.PartType.Ball
                    localPlayerSphere.Size = Vector3.new(1, 1, 1)
                    localPlayerSphere.Color = Color3.fromRGB(0, 0, 255)  -- Blue color
                    localPlayerSphere.Material = Enum.Material.Neon
                    localPlayerSphere.Anchored = true
                    localPlayerSphere.CanCollide = false
                    localPlayerSphere.Transparency = 0.5
                    localPlayerSphere.Parent = workspace
                end
                localPlayerSphere.Position = game.Players.LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 5, 0)

                -- Create or update the line between the two spheres
                if not lineBetweenSpheres then
                    lineBetweenSpheres = Instance.new("Part")
                    lineBetweenSpheres.Size = Vector3.new(0.2, 0.2, 0.2)
                    lineBetweenSpheres.Anchored = true
                    lineBetweenSpheres.CanCollide = false
                    lineBetweenSpheres.Transparency = 0.5
                    lineBetweenSpheres.Color = Color3.fromRGB(255, 255, 255)  -- White line
                    lineBetweenSpheres.Material = Enum.Material.Neon
                    lineBetweenSpheres.Parent = workspace
                end

                local midPoint = (targetSphere.Position + localPlayerSphere.Position) / 2
                lineBetweenSpheres.CFrame = CFrame.new(midPoint, targetSphere.Position)
                lineBetweenSpheres.Size = Vector3.new(0.2, 0.2, (targetSphere.Position - localPlayerSphere.Position).Magnitude)
            else
                -- If the target is out of range, remove the spheres and line
                if targetSphere then
                    targetSphere:Destroy()
                    targetSphere = nil
                end
                if localPlayerSphere then
                    localPlayerSphere:Destroy()
                    localPlayerSphere = nil
                end
                if lineBetweenSpheres then
                    lineBetweenSpheres:Destroy()
                    lineBetweenSpheres = nil
                end
                currentTarget = "❌"
                distanceToNearestPlayer = "❌"
            end
        else
            -- No target, remove the spheres and line
            if targetSphere then
                targetSphere:Destroy()
                targetSphere = nil
            end
            if localPlayerSphere then
                localPlayerSphere:Destroy()
                localPlayerSphere = nil
            end
            if lineBetweenSpheres then
                lineBetweenSpheres:Destroy()
                lineBetweenSpheres = nil
            end
            currentTarget = "❌"
            distanceToNearestPlayer = "❌"
        end
    else
        -- Turn Lock is off, remove the spheres and line
        if targetSphere then
            targetSphere:Destroy()
            targetSphere = nil
        end
        if localPlayerSphere then
            localPlayerSphere:Destroy()
            localPlayerSphere = nil
        end
        if lineBetweenSpheres then
            lineBetweenSpheres:Destroy()
            lineBetweenSpheres = nil
        end
        currentTarget = "❌"
        distanceToNearestPlayer = "❌"
    end

    TurnLockInput:SetValue(currentTarget)
    DistanceInput:SetValue(distanceToNearestPlayer .. " ")
end

-- Connect the updateTurnLock function to the Heartbeat event
game:GetService("RunService").Heartbeat:Connect(updateTurnLock)
